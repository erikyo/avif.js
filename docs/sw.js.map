{"version":3,"file":"sw.js","mappings":"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","sources":["webpack://avif.js/./node_modules/dav1d.js/dav1d.js","webpack://avif.js/./src/avif-service.ts","webpack://avif.js/./src/bmp.ts","webpack://avif.js/./src/mov.ts","webpack://avif.js/webpack/bootstrap","webpack://avif.js/webpack/runtime/define property getters","webpack://avif.js/webpack/runtime/hasOwnProperty shorthand","webpack://avif.js/./src/sw.ts"],"sourcesContent":["// Must be in sync with emcc settings!\nconst TOTAL_MEMORY = 64 * 1024 * 1024; // TODO(Kagami): Find optimal amount\nconst TOTAL_STACK = 5626096; // TODO(Kagami): Find why bigger than 5MB\nconst PAGE_SIZE = 64 * 1024;\nconst TABLE_SIZE = 271; // NOTE(Kagami): Depends on the number of\n                        // function pointers in target library, seems\n                        // like no way to know in general case\n\nfunction getRuntime() {\n  let dynamicTop = TOTAL_STACK;\n  const table = new WebAssembly.Table({\n    initial: TABLE_SIZE,\n    maximum: TABLE_SIZE,\n    element: \"anyfunc\",\n  });\n  const memory = new WebAssembly.Memory({\n    initial: TOTAL_MEMORY / PAGE_SIZE,\n    maximum: TOTAL_MEMORY / PAGE_SIZE,\n  });\n  const HEAPU8 = new Uint8Array(memory.buffer);\n  return {\n    table: table,\n    memory: memory,\n    sbrk: (increment) => {\n      const oldDynamicTop = dynamicTop;\n      dynamicTop += increment;\n      return oldDynamicTop;\n    },\n    emscripten_memcpy_big: (dest, src, num) => {\n      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);\n    },\n    // Empty stubs for dav1d.\n    pthread_cond_wait: (cond, mutex) => 0,\n    pthread_cond_signal: (cond) => 0,\n    pthread_cond_destroy: (cond) => 0,\n    pthread_cond_init: (cond, attr) => 0,\n    pthread_cond_broadcast: (cond) => 0,\n    pthread_join: (thread, res) => 0,\n    pthread_create: (thread, attr, func, arg) => 0,\n    // Emscripten debug.\n    // abort: () => {},\n    // __lock: () => {},\n    // __unlock: () => {},\n    // djs_log: (msg) => console.log(msg),\n  };\n}\n\nfunction fetchAndInstantiate(data, url, imports) {\n  if (data) return WebAssembly.instantiate(data, imports);\n  const req = fetch(url, {credentials: \"same-origin\"});\n  if (WebAssembly.instantiateStreaming) {\n    return WebAssembly.instantiateStreaming(req, imports);\n  } else {\n    return req\n      .then(res => res.arrayBuffer())\n      .then(data => WebAssembly.instantiate(data, imports));\n  }\n}\n\nexport function create(opts = {}) {\n  if (!opts.wasmURL && !opts.wasmData) {\n    return Promise.reject(new Error(\"Either wasmURL or wasmData shall be provided\"));\n  }\n  const runtime = getRuntime();\n  const imports = {env: runtime};\n  return fetchAndInstantiate(opts.wasmData, opts.wasmURL, imports).then(wasm => {\n    const d = new Dav1d({wasm, runtime});\n    d._init();\n    return d;\n  });\n}\n\nconst DJS_FORMAT_YUV = 0;\nconst DJS_FORMAT_BMP = 1;\n\nclass Dav1d {\n  /* Private methods, shall not be used */\n\n  constructor({wasm, runtime}) {\n    this.FFI = wasm.instance.exports;\n    this.buffer = runtime.memory.buffer;\n    this.HEAPU8 = new Uint8Array(this.buffer);\n    this.ref = null;\n    this.lastFrameRef = null;\n  }\n  _init() {\n    this.ref = this.FFI.djs_init();\n    if (!this.ref) throw new Error(\"error in djs_init\");\n  }\n  _decodeFrame(obu, format, unsafe) {\n    if (!ArrayBuffer.isView(obu)) {\n      obu = new Uint8Array(obu);\n    }\n    const obuRef = this.FFI.djs_alloc_obu(obu.byteLength);\n    if (!obuRef) throw new Error(\"error in djs_alloc_obu\");\n    this.HEAPU8.set(obu, obuRef);\n    const frameRef = this.FFI.djs_decode_obu(this.ref, obuRef, obu.byteLength, format);\n    if (!frameRef) throw new Error(\"error in djs_decode\");\n    const frameInfo = new Uint32Array(this.buffer, frameRef, 4);\n    const width = frameInfo[0];\n    const height = frameInfo[1];\n    const size = frameInfo[2];\n    const dataRef = frameInfo[3];\n    const srcData = new Uint8Array(this.buffer, dataRef, size);\n    if (unsafe) {\n      this.lastFrameRef = frameRef;\n      return srcData;\n    }\n    const data = new Uint8Array(size);\n    data.set(srcData);\n    this.FFI.djs_free_frame(frameRef);\n    return {width, height, data};\n  }\n\n  /* Public API methods */\n\n  /**\n   * Frame decoding, copy of frame data is returned.\n   */\n  decodeFrameAsYUV(obu) {\n    return this._decodeFrame(obu, DJS_FORMAT_YUV, false);\n  }\n  decodeFrameAsBMP(obu) {\n    return this._decodeFrame(obu, DJS_FORMAT_BMP, false);\n  }\n\n  /**\n   * Unsafe decoding with minimal overhead, pointer to WebAssembly\n   * memory is returned. User can't call any dav1d.js methods while\n   * keeping reference to it and shall call `unsafeCleanup` when\n   * finished using the data.\n   */\n  unsafeDecodeFrameAsYUV(obu) {\n    return this._decodeFrame(obu, DJS_FORMAT_YUV, true);\n  }\n  unsafeDecodeFrameAsBMP(obu) {\n    return this._decodeFrame(obu, DJS_FORMAT_BMP, true);\n  }\n  unsafeCleanup() {\n    if (this.lastFrameRef) {\n      this.FFI.djs_free_frame(this.lastFrameRef);\n      this.lastFrameRef = null;\n    }\n  }\n}\n\nexport default {create};\n","import { avif2mov, avif2obu } from './mov'\nimport { create } from 'dav1d.js'\n\n// AV1 decoder context.\nexport let decoderContext = null\n\nexport function initPolyfill (opts) {\n  if (!opts.usePolyfill) return Promise.resolve()\n  return create({ wasmURL: opts.wasmURL }).then(d => {\n    decoderContext = d\n  })\n}\n\nexport function arr2blob (bmpArr) {\n  return new Blob([bmpArr], { type: 'image/png' })\n}\n\nexport function nativeDecodeAvif (client, id, avifArr): Blob {\n  const movArr = avif2mov(avifArr)\n  client.postMessage({ id, type: 'avif-mov', data: movArr }, [movArr])\n}\n\n// Synchronous but that should be ok.\nexport function polyfillDecodeAvif (id, avifArr): Blob {\n  const obuArr = avif2obu(avifArr).data\n  resolveTask(id, toBlob => {\n    if (toBlob) {\n      // console.time(\"dav1d \"+id);\n      const bmpArr = decoderContext.unsafeDecodeFrameAsBMP(obuArr)\n      // console.timeEnd(\"dav1d \"+id);\n      const blob = arr2blob(bmpArr)\n      decoderContext.unsafeCleanup()\n      return blob\n    } else {\n      // Will be transfered so ok to copy.\n      return decoderContext.decodeFrameAsBMP(obuArr)\n    }\n  })\n}\n\nexport function decodeAvif (client, id, avifArr): Blob {\n  return decoderContext\n    ? polyfillDecodeAvif(client, id, avifArr)\n    : nativeDecodeAvif(client, id, avifArr)\n}\n","\n/**\n * Convert raw pixel data to BMP.\n * It takes a Uint8ClampedArray (ab) containing the RGBA values of a canvas, and returns an ArrayBuffer\n * (file) containing a BMP file\n * Based on canvas-to-bmp ((c) 2015 Ken \"Epistemex\" Fyrstenberg, MIT).\n * @param ab - the ArrayBuffer containing the image data\n * @param w - width of the image\n * @param h - height of the image\n * @returns A file\n */\nexport function rgba2bmp(ab, w, h) {\n  function setU16(v) {view.setUint16(pos, v, true); pos += 2;}\n  function setU32(v) {view.setUint32(pos, v, true); pos += 4;}\n\n  const headerSize = 54;                             // 14 + 40 bytes\n  const stride = Math.floor((24 * w + 31) / 32) * 4; // row length incl. padding\n  const pixelArraySize = stride * h;                 // total bitmap size\n  const fileLength = headerSize + pixelArraySize;    // header size is known + bitmap\n  const file = new ArrayBuffer(fileLength);          // raw byte buffer (returned)\n  const view = new DataView(file);                   // handle endian, reg. width etc.\n  const data32 = new Uint32Array(ab);                // 32-bit representation of canvas\n  const w3 = w * 3;\n  let pos32 = 0;\n  let pos = 0;\n  let y = 0;\n\n  // BMP header.\n  setU16(0x4d42);         // BM\n  setU32(fileLength);     // total length\n  pos += 4;               // skip unused fields\n  setU32(headerSize);     // offset to pixels\n\n  // DIB header.\n  setU32(40);             // DIB header size\n  setU32(w);              // width\n  setU32(-h >>> 0);       // negative = top-to-bottom\n  setU16(1);              // 1 plane\n  setU16(24);             // 24-bit (RGB)\n  setU32(0);              // no compression (BI_RGB)\n  setU32(pixelArraySize); // bitmap size incl. padding (stride x height)\n  setU32(2835);           // pixels/meter h (~72 DPI x 39.3701 inch/m)\n  setU32(2835);           // pixels/meter v\n\n  // Bitmap data, change order from ABGR to BGR.\n  while (y < h) {\n    const shift = headerSize + y * stride;\n    let x = 0;\n    while (x < w3) {\n      const abgr = data32[pos32++];\n      const bg = (abgr >> 8) & 0xffff;\n      const r = abgr & 0xff;\n      view.setUint16(shift + x, bg);\n      view.setUint8(shift + x + 2, r);\n      x += 3;\n    }\n    y++;\n  }\n\n  return file;\n}\n","// ISOBMFF constants.\nconst BOX_HEADER_SIZE = 8\nconst BOX_FTYP = 0x66747970\nconst BOX_META = 0x6d657461\nconst BOX_ILOC = 0x696c6f63\nconst BOX_IPRP = 0x69707270\nconst BOX_IPCO = 0x6970636f\nconst BOX_ISPE = 0x69737065\n\n// MOV container stub with single video track.\nconst MOV_HEADER = (function () {\n  const u32 = new Uint32Array([469762048, 1887007846, 1836020585, 131072, 1836020585, 846164841, 825520237, 1140981760, 1987014509, 1811939328, 1684567661, 0, 0, 0, 3892510720, 704643072, 256, 1, 0, 0, 256, 0, 0, 0, 256, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 33554432, 3489726464, 1801548404, 1543503872, 1684564852, 50331648, 0, 0, 16777216, 0, 704643072, 0, 0, 0, 0, 256, 0, 0, 0, 256, 0, 0, 0, 64, 32775, 14340, 1812004864, 1634296941, 536870912, 1684563053, 0, 0, 0, 3227320320, 3909287936, 50261, 553648128, 1919706216, 0, 0, 1701079414, 0, 0, 0, 16777216, 1852402979, 102, 1752004116, 100, 1, 0, 0, 1852400676, 102, 1701995548, 102, 0, 1, 1819440396, 32, 1, 1651799011, 108, 1937011583, 100, 0, 1, 813064559, 49, 0, 1, 0, 0, 0, 75499264, 4718648, 4718592, 0, 65536, 0, 0, 0, 0, 0, 0, 0, 0, 16776984, 1629028352, 2168664438, 167775240, 11, 3284118338, 31915895, 402653184, 1937011827, 0, 16777216, 16777216, 3909287936, 469762048, 1668510835, 0, 16777216, 16777216, 16777216, 16777216, 335544320, 2054386803, 0, 0, 16777216, 335544320, 1868788851, 0, 16777216, 1744961536, 0, 1952539757])\n  return new Uint8Array(u32.buffer)\n})()\nconst MOV_HEADER_SIZE = MOV_HEADER.byteLength\nconst MOV_STSZ_OFFSET = 568\nconst MOV_MDAT_OFFSET = 608\nconst MOV_TKHD_WIDTH_OFFSET = 234\nconst MOV_AV01_WIDTH_OFFSET = 437\n\nfunction assert (cond, str) {\n  if (!cond) throw new Error(str)\n}\n\n/**\n * It parses the AVIF file\n * header, extracts the image dimensions and the actual image data, and returns\n * them as an object\n * @param ab - The ArrayBuffer of the AVIF file.\n * @returns An object with the width, height, and data of the image.\n */\nexport function avif2obu (ab) {\n  function getU8 () { const v = view.getUint8(pos); pos += 1; return v }\n  function getU16 () { const v = view.getUint16(pos); pos += 2; return v }\n  function getU32 () { const v = view.getUint32(pos); pos += 4; return v }\n\n  const view = new DataView(ab)\n  const len = ab.byteLength\n  let pos = 0\n\n  let brandsCheck = false\n  let width = 0\n  let height = 0\n  let data = null\n\n  while (pos < len) {\n    const size = getU32()\n    const type = getU32()\n    const end = pos + size - BOX_HEADER_SIZE\n    assert(size >= BOX_HEADER_SIZE, 'corrupted file')\n\n    // TODO(Kagami): Add box version checks!\n    switch (type) {\n      case BOX_FTYP:\n      // FIXME(Kagami): Check brands.\n      // TODO(Kagami): Also check that meta/hdlr.handler = \"pict\".\n        brandsCheck = true\n        break\n      case BOX_META:\n        pos += 1 // version\n        pos += 3 // flags\n        continue\n      case BOX_IPRP:\n        continue\n      case BOX_IPCO:\n        continue\n      case BOX_ISPE:\n        pos += 1 // version\n        pos += 3 // flags\n        width = getU32()\n        height = getU32()\n        break\n      case BOX_ILOC:\n        pos += 1 // version\n        pos += 3 // flags\n        const offsetSizeAndLengthSize = getU8()\n        const offsetSize = offsetSizeAndLengthSize >>> 4\n        assert(offsetSize < 8, 'unsupported offset size')\n        const lengthSize = offsetSizeAndLengthSize & 0xf\n        assert(lengthSize < 8, 'unsupported length size')\n        const baseOffsetSize = getU8() >>> 4\n        assert(baseOffsetSize < 8, 'unsupported base offset size')\n        const itemCount = getU16()\n        assert(itemCount >= 1, 'bad iloc items number')\n        // XXX(Kagami): Choosing first item for simplicity.\n        // TODO(Kagami): Use primary item (meta/pitm/item_ID).\n        // TODO(Kagami): Also check that meta/iinf/infe[i].item_type = \"av01\".\n        pos += 2 // item_ID\n        pos += 2 // data_reference_index\n        const baseOffset = baseOffsetSize === 4 ? getU32() : 0\n        pos += 2 // extent_count (>= 1)\n        // XXX(Kagami): What should we do if extent_count > 1?\n        const extentOffset = offsetSize === 4 ? getU32() : 0\n        const extentLength = lengthSize === 4 ? getU32() : 0\n        const u8 = new Uint8Array(ab)\n        const offset = baseOffset + extentOffset\n        data = u8.subarray(offset, offset + extentLength)\n        break\n    }\n\n    pos = end\n  }\n\n  assert(brandsCheck, 'bad brands')\n  assert(width && height, 'bad image width or height')\n  assert(data, 'picture data not found')\n  return { width, height, data }\n}\n\n/**\n * It takes a WebM file and converts it to a MOV file\n * Embed OBU into MOV container stub as video frame.\n * TODO(Kagami): Fix matrix, bitdepth, av1C metadata.\n * @param  - `width` - the width of the video\n * @returns An ArrayBuffer\n */\nexport function obu2mov ({ width, height, data }) {\n  const fileSize = MOV_HEADER_SIZE + data.byteLength\n  const ab = new ArrayBuffer(fileSize)\n  const view = new DataView(ab)\n  const u8 = new Uint8Array(ab)\n  u8.set(MOV_HEADER)\n  u8.set(data, MOV_HEADER_SIZE)\n  // |....|stsz|.|...|xxxx|\n  view.setUint32(MOV_STSZ_OFFSET + BOX_HEADER_SIZE + 4, data.byteLength)\n  // |xxxx|mdat|\n  view.setUint32(MOV_MDAT_OFFSET, data.byteLength + BOX_HEADER_SIZE)\n  // |xxxx|xxxx|\n  view.setUint32(MOV_TKHD_WIDTH_OFFSET, width)\n  view.setUint32(MOV_TKHD_WIDTH_OFFSET + 4, height)\n  // |xx|xx|\n  view.setUint16(MOV_AV01_WIDTH_OFFSET, width)\n  view.setUint16(MOV_AV01_WIDTH_OFFSET + 2, height)\n  return ab\n}\n\n/**\n * Remux AVIF picture as MOV video with single frame.\n * @param ab - ArrayBuffer of the AVIF file\n * @returns A function that takes an array buffer\n */\nexport function avif2mov (ab) {\n  return obu2mov(avif2obu(ab))\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { rgba2bmp } from './bmp'\nimport { avif2obu } from './mov'\nimport { arr2blob, initPolyfill, nativeDecodeAvif } from './avif-service'\n\nconst CACHE_NAME = 'avifCache'\nconst CACHE_VERSION = 1\nconst CURRENT_CACHES = {\n  AvifCache: `${CACHE_NAME}-V${CACHE_VERSION}`\n}\n\n// Wait for client to become ready.\nexport const waitForClient = {}\n\n// Pending tasks.\nexport const taskById = {}\nexport let taskCounter = 0\n\n// AV1 decoder context.\nexport const dCtx = null\n\nfunction setClientReady (cid) {\n  if (waitForClient[cid]) {\n    waitForClient[cid].resolve()\n  } else {\n    waitForClient[cid] = { ready: Promise.resolve(), resolve: null }\n  }\n}\n\nfunction setClientWaiting (cid) {\n  if (!waitForClient[cid]) {\n    let resolve = null\n    const ready = new Promise(res => { resolve = res })\n    waitForClient[cid] = { ready, resolve }\n  }\n}\n\nfunction resolveTask (taskId, cb) {\n  const task = taskById[taskId]\n  if (task) {\n    task.resolve(cb(task.toBlob))\n  }\n}\n\nfunction rejectTask (taskId, err) {\n  const task = taskById[taskId]\n  if (task) {\n    task.reject(err)\n  }\n}\n\n// Synchronous but that should be ok.\nfunction polyfillDecodeAvif (client, id, avifArr) {\n  const obuArr = avif2obu(avifArr).data\n  resolveTask(id, toBlob => {\n    if (toBlob) {\n      // console.time(\"dav1d \"+id);\n      const bmpArr = dCtx.unsafeDecodeFrameAsBMP(obuArr)\n      // console.timeEnd(\"dav1d \"+id);\n      const blob = arr2blob(bmpArr)\n      dCtx.unsafeCleanup()\n      return blob\n    } else {\n      // Will be transfered so ok to copy.\n      return dCtx.decodeFrameAsBMP(obuArr)\n    }\n  })\n}\n\nfunction decodeAvif (client, id, avifArr) {\n  return waitForClient[client.id].ready.then(() => {\n    dCtx\n      ? polyfillDecodeAvif(client, id, avifArr)\n      : nativeDecodeAvif(client, id, avifArr)\n  })\n}\n\nself.addEventListener('install', (event) => {\n  // The promise that skipWaiting() returns can be safely ignored.\n  self.skipWaiting()\n})\n\n// The activate handler takes care of cleaning up old caches.\nself.addEventListener('activate', event => {\n  const currentCaches = [CURRENT_CACHES]\n  event.waitUntil(\n    caches.keys().then(cacheNames => {\n      return cacheNames.filter(cacheName => !currentCaches.includes(cacheName))\n    }).then(async cachesToDelete => {\n      return await Promise.all(cachesToDelete.map(async cacheToDelete => {\n        return await caches.delete(cacheToDelete)\n      }))\n    }).then(async () => { await self.clients.claim() })\n  )\n})\n\n// Handle job messages.\nself.addEventListener('message', e => {\n  const msg = e.data\n  if (!msg) return\n\n  switch (msg.type) {\n    // Client asks for our update\n    case 'avif-update':\n      self.skipWaiting()\n      break\n\n    // Client asks to activate us right away\n    case 'avif-claim':\n      clients.claim()\n      break\n\n    // Client is ready\n    case 'avif-ready':\n      initPolyfill(msg.data).then(() => { setClientReady(e.source.id) })\n      break\n\n    // Client sent task result\n    case 'avif-rgba':\n      const bmpArr = rgba2bmp(msg.data, msg.width, msg.height)\n      resolveTask(msg.id, toBlob => toBlob ? arr2blob(bmpArr) : bmpArr)\n      break\n\n    // Client sent task error\n    case 'avif-error':\n      rejectTask(msg.id, new Error(msg.data))\n      break\n\n    // Client sent task request\n    case 'avif-task':\n      const client = e.source\n      const id = msg.id\n      new Promise((resolve, reject) => {\n        taskById[id] = { resolve, reject, toBlob: false }\n        decodeAvif(client, id, msg.data)\n      }).then(bmpArr => {\n        delete taskById[id]\n        client.postMessage({ id, type: 'avif-task', data: bmpArr }, [bmpArr])\n      }, err => {\n        delete taskById[id]\n        client.postMessage({ id, type: 'avif-error', data: err.message })\n      })\n      break\n    default:\n      break\n  }\n})\n\n// This function is used to convert base64 encoding to mime type (blob)\nfunction blobToBlob (imageBlob, mime): Blob {\n  const canvas = document.createElement('canvas')\n  const context = canvas.getContext('2d')\n\n  let newBlob\n\n  // Create a new Image object and set its source to the Blob URL\n  const img = new Image()\n  img.src = URL.createObjectURL(imageBlob)\n\n  // When the image has loaded, draw it onto the canvas with the desired file format\n  img.onload = function () {\n    canvas.width = img.width\n    canvas.height = img.height\n    context.drawImage(img, 0, 0)\n\n    // Convert the canvas to a new Blob with the desired file format\n    canvas.toBlob(function (nb) {\n      newBlob = nb\n    }, mime)\n  }\n\n  return newBlob\n}\n\nself.addEventListener('fetch', (event) => {\n  console.log('Handling fetch event for', event.request.url)\n\n  if (event.request.url.match(/\\.avif$/i)) {\n    const id = taskCounter++\n    setClientWaiting(event.clientId)\n\n    event.respondWith(caches.open(CURRENT_CACHES.AvifCache)\n      .then(async (cache: Cache) => {\n        return await cache.match(event.request)\n          .then((cachedResponse: Response | undefined) => {\n            console.log(event.request)\n            return (cachedResponse != null) || new Promise((resolve, reject) => {\n              taskById[id] = { resolve, reject, toBlob: true }\n\n              clients.get(event.clientId).then(async (client: Client) => {\n                return await fetch(event.request.url, { credentials: 'same-origin' })\n                  .then(async res => await res.arrayBuffer())\n                  .then(avifArr => decodeAvif(client, id, avifArr))\n              }).catch(reject)\n            })\n              .then((blob: Blob) => {\n                delete taskById[id]\n                return new Response(blob)\n              }, err => {\n                delete taskById[id]\n                throw err\n              })\n          })\n          .catch((error) => {\n            console.error('  Error in fetch handler:', error)\n\n            throw error\n          })\n      })\n    )\n  }\n})\n"],"names":["TOTAL_MEMORY","TOTAL_STACK","PAGE_SIZE","TABLE_SIZE","create","opts","wasmURL","wasmData","Promise","reject","Error","dynamicTop","table","memory","HEAPU8","runtime","WebAssembly","Table","initial","maximum","element","Memory","Uint8Array","buffer","sbrk","increment","oldDynamicTop","emscripten_memcpy_big","dest","src","num","set","subarray","pthread_cond_wait","cond","mutex","pthread_cond_signal","pthread_cond_destroy","pthread_cond_init","attr","pthread_cond_broadcast","pthread_join","thread","res","pthread_create","func","arg","imports","env","data","url","instantiate","req","fetch","credentials","instantiateStreaming","then","arrayBuffer","fetchAndInstantiate","wasm","d","Dav1d","_init","this","FFI","instance","exports","ref","lastFrameRef","djs_init","obu","format","unsafe","ArrayBuffer","isView","obuRef","djs_alloc_obu","byteLength","frameRef","djs_decode_obu","frameInfo","Uint32Array","width","height","size","dataRef","srcData","djs_free_frame","_decodeFrame","initPolyfill","usePolyfill","resolve","arr2blob","bmpArr","Blob","type","nativeDecodeAvif","client","id","avifArr","movArr","avif2mov","postMessage","rgba2bmp","ab","w","h","setU16","v","view","setUint16","pos","setU32","setUint32","stride","Math","floor","pixelArraySize","fileLength","file","DataView","data32","w3","pos32","y","shift","x","abgr","bg","r","setUint8","u32","BOX_HEADER_SIZE","BOX_FTYP","BOX_META","BOX_ILOC","BOX_IPRP","BOX_IPCO","BOX_ISPE","MOV_HEADER","MOV_HEADER_SIZE","MOV_STSZ_OFFSET","MOV_MDAT_OFFSET","MOV_TKHD_WIDTH_OFFSET","MOV_AV01_WIDTH_OFFSET","assert","str","avif2obu","getU8","getUint8","getU32","getUint32","len","brandsCheck","end","offsetSizeAndLengthSize","offsetSize","lengthSize","baseOffsetSize","getUint16","baseOffset","extentOffset","extentLength","offset","fileSize","u8","obu2mov","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","module","__webpack_modules__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","i","CURRENT_CACHES","AvifCache","waitForClient","taskById","taskCounter","dCtx","resolveTask","taskId","cb","task","toBlob","decodeAvif","ready","obuArr","unsafeDecodeFrameAsBMP","blob","unsafeCleanup","decodeFrameAsBMP","polyfillDecodeAvif","self","addEventListener","event","skipWaiting","currentCaches","waitUntil","caches","keys","cacheNames","filter","cacheName","includes","cachesToDelete","all","map","cacheToDelete","clients","claim","e","err","msg","cid","source","message","console","log","request","match","setClientWaiting","clientId","respondWith","open","cache","cachedResponse","Response","error"],"sourceRoot":""}