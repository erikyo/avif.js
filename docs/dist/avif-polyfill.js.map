{"version":3,"file":"dist/avif-polyfill.js","mappings":"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","sources":["webpack://avif.js/webpack/universalModuleDefinition","webpack://avif.js/./node_modules/dav1d.js/dav1d.js","webpack://avif.js/./src/avif-service.ts","webpack://avif.js/./src/avif-sw.ts","webpack://avif.js/./src/bmp.ts","webpack://avif.js/./src/constants.ts","webpack://avif.js/./src/decode.ts","webpack://avif.js/./src/index.ts","webpack://avif.js/./src/mov.ts","webpack://avif.js/./src/registration.ts","webpack://avif.js/./src/supportDetection.ts","webpack://avif.js/webpack/bootstrap","webpack://avif.js/webpack/runtime/define property getters","webpack://avif.js/webpack/runtime/harmony module decorator","webpack://avif.js/webpack/runtime/hasOwnProperty shorthand","webpack://avif.js/webpack/runtime/make namespace object","webpack://avif.js/webpack/before-startup","webpack://avif.js/webpack/startup","webpack://avif.js/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"avifPolyfill\"] = factory();\n\telse\n\t\troot[\"avifPolyfill\"] = factory();\n})(this, () => {\nreturn ","// Must be in sync with emcc settings!\nconst TOTAL_MEMORY = 64 * 1024 * 1024; // TODO(Kagami): Find optimal amount\nconst TOTAL_STACK = 5626096; // TODO(Kagami): Find why bigger than 5MB\nconst PAGE_SIZE = 64 * 1024;\nconst TABLE_SIZE = 271; // NOTE(Kagami): Depends on the number of\n                        // function pointers in target library, seems\n                        // like no way to know in general case\n\nfunction getRuntime() {\n  let dynamicTop = TOTAL_STACK;\n  const table = new WebAssembly.Table({\n    initial: TABLE_SIZE,\n    maximum: TABLE_SIZE,\n    element: \"anyfunc\",\n  });\n  const memory = new WebAssembly.Memory({\n    initial: TOTAL_MEMORY / PAGE_SIZE,\n    maximum: TOTAL_MEMORY / PAGE_SIZE,\n  });\n  const HEAPU8 = new Uint8Array(memory.buffer);\n  return {\n    table: table,\n    memory: memory,\n    sbrk: (increment) => {\n      const oldDynamicTop = dynamicTop;\n      dynamicTop += increment;\n      return oldDynamicTop;\n    },\n    emscripten_memcpy_big: (dest, src, num) => {\n      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);\n    },\n    // Empty stubs for dav1d.\n    pthread_cond_wait: (cond, mutex) => 0,\n    pthread_cond_signal: (cond) => 0,\n    pthread_cond_destroy: (cond) => 0,\n    pthread_cond_init: (cond, attr) => 0,\n    pthread_cond_broadcast: (cond) => 0,\n    pthread_join: (thread, res) => 0,\n    pthread_create: (thread, attr, func, arg) => 0,\n    // Emscripten debug.\n    // abort: () => {},\n    // __lock: () => {},\n    // __unlock: () => {},\n    // djs_log: (msg) => console.log(msg),\n  };\n}\n\nfunction fetchAndInstantiate(data, url, imports) {\n  if (data) return WebAssembly.instantiate(data, imports);\n  const req = fetch(url, {credentials: \"same-origin\"});\n  if (WebAssembly.instantiateStreaming) {\n    return WebAssembly.instantiateStreaming(req, imports);\n  } else {\n    return req\n      .then(res => res.arrayBuffer())\n      .then(data => WebAssembly.instantiate(data, imports));\n  }\n}\n\nexport function create(opts = {}) {\n  if (!opts.wasmURL && !opts.wasmData) {\n    return Promise.reject(new Error(\"Either wasmURL or wasmData shall be provided\"));\n  }\n  const runtime = getRuntime();\n  const imports = {env: runtime};\n  return fetchAndInstantiate(opts.wasmData, opts.wasmURL, imports).then(wasm => {\n    const d = new Dav1d({wasm, runtime});\n    d._init();\n    return d;\n  });\n}\n\nconst DJS_FORMAT_YUV = 0;\nconst DJS_FORMAT_BMP = 1;\n\nclass Dav1d {\n  /* Private methods, shall not be used */\n\n  constructor({wasm, runtime}) {\n    this.FFI = wasm.instance.exports;\n    this.buffer = runtime.memory.buffer;\n    this.HEAPU8 = new Uint8Array(this.buffer);\n    this.ref = null;\n    this.lastFrameRef = null;\n  }\n  _init() {\n    this.ref = this.FFI.djs_init();\n    if (!this.ref) throw new Error(\"error in djs_init\");\n  }\n  _decodeFrame(obu, format, unsafe) {\n    if (!ArrayBuffer.isView(obu)) {\n      obu = new Uint8Array(obu);\n    }\n    const obuRef = this.FFI.djs_alloc_obu(obu.byteLength);\n    if (!obuRef) throw new Error(\"error in djs_alloc_obu\");\n    this.HEAPU8.set(obu, obuRef);\n    const frameRef = this.FFI.djs_decode_obu(this.ref, obuRef, obu.byteLength, format);\n    if (!frameRef) throw new Error(\"error in djs_decode\");\n    const frameInfo = new Uint32Array(this.buffer, frameRef, 4);\n    const width = frameInfo[0];\n    const height = frameInfo[1];\n    const size = frameInfo[2];\n    const dataRef = frameInfo[3];\n    const srcData = new Uint8Array(this.buffer, dataRef, size);\n    if (unsafe) {\n      this.lastFrameRef = frameRef;\n      return srcData;\n    }\n    const data = new Uint8Array(size);\n    data.set(srcData);\n    this.FFI.djs_free_frame(frameRef);\n    return {width, height, data};\n  }\n\n  /* Public API methods */\n\n  /**\n   * Frame decoding, copy of frame data is returned.\n   */\n  decodeFrameAsYUV(obu) {\n    return this._decodeFrame(obu, DJS_FORMAT_YUV, false);\n  }\n  decodeFrameAsBMP(obu) {\n    return this._decodeFrame(obu, DJS_FORMAT_BMP, false);\n  }\n\n  /**\n   * Unsafe decoding with minimal overhead, pointer to WebAssembly\n   * memory is returned. User can't call any dav1d.js methods while\n   * keeping reference to it and shall call `unsafeCleanup` when\n   * finished using the data.\n   */\n  unsafeDecodeFrameAsYUV(obu) {\n    return this._decodeFrame(obu, DJS_FORMAT_YUV, true);\n  }\n  unsafeDecodeFrameAsBMP(obu) {\n    return this._decodeFrame(obu, DJS_FORMAT_BMP, true);\n  }\n  unsafeCleanup() {\n    if (this.lastFrameRef) {\n      this.FFI.djs_free_frame(this.lastFrameRef);\n      this.lastFrameRef = null;\n    }\n  }\n}\n\nexport default {create};\n","import { avif2mov } from './mov'\nimport { rasterFormat } from './constants'\n\n// Wait for client to become ready.\nexport const waitForClient = []\n\n/**\n * It takes an array of bytes and returns a blob\n * @param bmpArr - the array of bytes that make up the BMP file\n * @returns A blob object.\n */\nexport function arr2blob (bmpArr) {\n  return new Blob([bmpArr], { type: rasterFormat })\n}\n\n/**\n * It creates a promise that resolves immediately if it already exists, or creates a new promise that\n * resolves immediately if it doesn't exist\n * @param [cid=0] - The client ID of the client that is ready.\n */\nexport function setClientReady (cid = 0) {\n  if (waitForClient[cid]) {\n    waitForClient[cid].resolve()\n  } else {\n    waitForClient[cid] = { ready: Promise.resolve(), resolve: null }\n  }\n}\n\n/**\n * It creates a promise that will be resolved when the client is ready\n * @param cid - The client ID of the client that is waiting.\n */\nexport function setClientWaiting (cid) {\n  if (!waitForClient[cid]) {\n    let resolve = null\n    const ready = new Promise(res => { resolve = res })\n    waitForClient[cid] = { ready, resolve }\n  }\n}\n\n/**\n * It converts an AVIF file to a MOV file, and then sends the MOV file to the main thread\n * @param client - the worker client\n * @param id - The id of the message that was sent from the main thread.\n * @param avifArr - the Uint8Array of the AVIF file\n */\nexport function nativeDecodeAvif (client, id, avifArr): Blob {\n  const movArr = avif2mov(avifArr)\n  client.postMessage({ id, type: 'avif-mov', data: movArr }, [movArr])\n}\n","import { rgba2bmp } from './bmp'\nimport { arr2blob, setClientReady, setClientWaiting } from './avif-service'\nimport { decodeAvif, polyfillAvif } from './decode'\n\nconst CACHE_NAME = 'avifCache'\nconst CACHE_VERSION = 1\nconst CURRENT_CACHES = {\n  AvifCache: `${CACHE_NAME}-V${CACHE_VERSION}`\n}\n\n// Pending tasks.\nexport const taskById: Array<{ resolve: Promise<boolean>, reject: PromiseRejectionEvent, toBlob: boolean }> = {}\nexport let taskCounter = 0\n\n/**\n * It takes a taskId and a callback function, and if the taskId is valid, it calls the callback\n * function with the task's toBlob function as an argument\n * @param taskId - The id of the task.\n * @param cb - a callback function that takes a single parameter, which is a function that returns a\n * Blob.\n */\nexport function resolveTask (taskId, cb) {\n  const task = taskById[taskId]\n  if (task) {\n    task.resolve(cb(task.toBlob))\n  }\n}\n\n/**\n * It rejects a task by its id\n * @param taskId - The id of the task.\n * @param err - The error message to be passed to the reject function.\n */\nexport function rejectTask (taskId, err) {\n  const task = taskById[taskId]\n  if (task) {\n    task.reject(err)\n  }\n}\n\n/* A service worker event listener that is called when the service worker is installed. */\nself.addEventListener('install', (event) => {\n  // The promise that skipWaiting() returns can be safely ignored.\n  self.skipWaiting()\n})\n\n/**\n * Cleaning up old caches.\n * The activate handler takes care of cleaning up old caches.\n */\nself.addEventListener('activate', event => {\n  const currentCaches = [CURRENT_CACHES]\n  event.waitUntil(\n    caches.keys().then(cacheNames => {\n      return cacheNames.filter(cacheName => !currentCaches.includes(cacheName))\n    }).then(async cachesToDelete => {\n      return await Promise.all(cachesToDelete.map(async cacheToDelete => {\n        return await caches.delete(cacheToDelete)\n      }))\n    }).then(async () => { await self.clients.claim() })\n  )\n})\n\n/* Listening for messages from the client. */\nself.addEventListener('message', (event: MessageEvent) => {\n\n  if (event.data === undefined) return\n\n  // Handle job messages.\n  const msg = event.data\n\n  switch (msg.type) {\n    // Client asks for our update\n    case 'avif-update':\n      self.skipWaiting()\n      break\n\n    // Client asks to activate us right away\n    case 'avif-claim':\n      clients.claim()\n      break\n\n    // Client asks to activate us right away\n    case 'avif-unload':\n      console.log('cleanup received!')\n      caches.keys().then(async function (cacheNames) {\n        return await Promise.all(\n          cacheNames.map(async function (cacheName) {\n            return await caches.delete(cacheName)\n          })\n        )\n      })\n      break\n\n    // Client is ready\n    case 'avif-replace':\n      console.log(msg.data)\n      polyfillAvif(msg.data).then(() => { setClientReady(event.source.id) })\n      break\n\n    // Client asks to activate us right away\n    case 'uninstall':\n      console.log('uninstall command received! bye bye!')\n      self.sessionStorage.clear()\n      break\n\n    // Client sent task result\n    case 'avif-rgba':\n      const bmpArr = rgba2bmp(msg.data, msg.width, msg.height)\n      resolveTask(msg.id, toBlob => toBlob ? arr2blob(bmpArr) : bmpArr)\n      break\n\n    // Client sent task error\n    case 'avif-error':\n      rejectTask(msg.id, new Error(msg.data))\n      break\n\n    // Client sent task request\n    case 'avif-task':\n      const client = event.source\n      const id = msg.id\n      new Promise((resolve, reject) => {\n        taskById[id] = { resolve, reject, toBlob: false }\n        console.log(msg.data);\n        decodeAvif(client, id, msg.data)\n      }).then(bmpArr => {\n        delete taskById[id]\n        client.postMessage({ id, type: 'avif-task', data: bmpArr }, [bmpArr])\n      }, err => {\n        delete taskById[id]\n        client.postMessage({ id, type: 'avif-error', data: err.message })\n      })\n      break\n\n    default:\n      break\n  }\n})\n\n/* A service worker event listener that is called when the service worker is installed. */\nself.addEventListener('fetch', (event) => {\n  console.log('Handling fetch event for', event.request.url)\n\n  /**\n   * if the requested file is an avif\n   */\n  if (event.request.url.match(/\\.avif$/i)) {\n    const id = taskCounter++\n    setClientWaiting(event.clientId)\n\n    /**\n     * search in cache for that file\n     */\n    event.respondWith(\n      caches\n        .open(CURRENT_CACHES.AvifCache)\n        .then(async (cache: Cache) => {\n          return await cache.match(event.request)\n\n            .then((cachedResponse: Response | undefined) => {\n              console.log(event.request.url + (cachedResponse != null ? ' cached ' : ' not cached'))\n\n              /**\n             * return the file OR fetch network for the requested file\n             */\n              return (cachedResponse != null) || new Promise((resolve, reject) => {\n                taskById[id] = { resolve, reject, toBlob: true }\n\n                clients.get(event.clientId).then(async (client: Client | undefined) => {\n                  return await fetch(event.request.clone(), { credentials: 'same-origin' })\n\n                    .then(async res => await res.arrayBuffer())\n                    .then((avifArr) => {\n                      return decodeAvif(client, id, avifArr)\n                    })\n                })\n                  .catch(reject)\n              })\n                .then((blob: Blob) => {\n                  delete taskById[id]\n\n                  cache.put(event.request.url + '.cache', new Response(blob))\n                    .then(\n                      () => { console.log(event.request.url + '.cache stored') }\n                    )\n\n                  return new Response(blob)\n                }, err => {\n                  delete taskById[id]\n                  throw err\n                })\n            })\n            .catch((error) => {\n              console.error('  Error in fetch handler:', error)\n              throw error\n            })\n        })\n    )\n  }\n})\n","/**\n * Convert raw pixel data to BMP.\n * It takes a Uint8ClampedArray (ab) containing the RGBA values of a canvas, and returns an ArrayBuffer\n * (file) containing a BMP file\n * Based on canvas-to-bmp ((c) 2015 Ken \"Epistemex\" Fyrstenberg, MIT).\n * @param ab - the ArrayBuffer containing the image data\n * @param w - width of the image\n * @param h - height of the image\n * @returns A file\n */\nexport function rgba2bmp (ab, w, h) {\n  function setU16 (v) { view.setUint16(pos, v, true); pos += 2 }\n  function setU32 (v) { view.setUint32(pos, v, true); pos += 4 }\n\n  const headerSize = 54 // 14 + 40 bytes\n  const stride = Math.floor((24 * w + 31) / 32) * 4 // row length incl. padding\n  const pixelArraySize = stride * h // total bitmap size\n  const fileLength = headerSize + pixelArraySize // header size is known + bitmap\n  const file = new ArrayBuffer(fileLength) // raw byte buffer (returned)\n  const view = new DataView(file) // handle endian, reg. width etc.\n  const data32 = new Uint32Array(ab) // 32-bit representation of canvas\n  const w3 = w * 3\n  let pos32 = 0\n  let pos = 0\n  let y = 0\n\n  // BMP header.\n  setU16(0x4d42) // BM\n  setU32(fileLength) // total length\n  pos += 4 // skip unused fields\n  setU32(headerSize) // offset to pixels\n\n  // DIB header.\n  setU32(40) // DIB header size\n  setU32(w) // width\n  setU32(-h >>> 0) // negative = top-to-bottom\n  setU16(1) // 1 plane\n  setU16(24) // 24-bit (RGB)\n  setU32(0) // no compression (BI_RGB)\n  setU32(pixelArraySize) // bitmap size incl. padding (stride x height)\n  setU32(2835) // pixels/meter h (~72 DPI x 39.3701 inch/m)\n  setU32(2835) // pixels/meter v\n\n  // Bitmap data, change order from ABGR to BGR.\n  while (y < h) {\n    const shift = headerSize + y * stride\n    let x = 0\n    while (x < w3) {\n      const abgr = data32[pos32++]\n      const bg = (abgr >> 8) & 0xffff\n      const r = abgr & 0xff\n      view.setUint16(shift + x, bg)\n      view.setUint8(shift + x + 2, r)\n      x += 3\n    }\n    y++\n  }\n\n  return file\n}\n","export const AVIF_SERVICE_WORKER_FILE = 'avif-sw.js'\nexport const rasterFormat = 'image/bmp'\n\nexport const avifPolyfillOptions = {\n  onUpdate: () => null,\n  swURL: AVIF_SERVICE_WORKER_FILE,\n  wasmURL: '/dist/dav1d.wasm',\n  forcePolyfill: false,\n  scope: '/'\n}\n","import { isEdge } from './registration'\nimport { hasAv1Support } from './supportDetection'\nimport { avif2obu } from './mov'\nimport { arr2blob, nativeDecodeAvif, waitForClient } from './avif-service'\nimport { resolveTask } from './avif-sw'\nimport { create } from 'dav1d.js'\n\n// AV1 decoder context.\nexport let decoderContext = null\n\n/**\n * Decode AVIF data using native browser's AV1 decoder.\n * It creates a video element, sets its src to the input, waits for the video to load, then draws the\n * video to a canvas and returns the canvas's image data\n * @param {ArrayBufferView | ArrayBuffer | Blob | string} arr - ArrayBufferView | ArrayBuffer | Blob |\n * string\n * @returns A promise that resolves to an object with a width, height, and data property.\n */\nexport async function decodeMov (arr: ArrayBufferView | ArrayBuffer | Blob | string) {\n  const blob = new Blob([arr], { type: 'video/mp4' })\n  const blobURL = URL.createObjectURL(blob)\n  return await new Promise((resolve, reject) => {\n    const vid: HTMLVideoElement = document.createElement('video')\n    vid.addEventListener(isEdge ? 'ended' : 'loadeddata', () => {\n      if ((vid.mozDecodedFrames == null ||\n          vid.mozDecodedFrames > 0) &&\n        (vid.webkitDecodedFrameCount == null ||\n          vid.webkitDecodedFrameCount > 0)) {\n        resolve(vid)\n      } else {\n        reject(new Error('partial AV1 frame'))\n      }\n    })\n    vid.addEventListener('error', () => {\n      reject(new Error('cannot decode AV1 frame'))\n    })\n    vid.muted = true\n    vid.src = blobURL\n    vid.play()\n  }).then(vid => {\n    /**\n     * maybe a separate function since is widely used\n     */\n\n    const c = document.createElement('canvas')\n    const ctx = c.getContext('2d')\n    c.width = vid.videoWidth\n    c.height = vid.videoHeight\n    ctx.drawImage(vid, 0, 0, c.width, c.height)\n    const imgData = ctx.getImageData(0, 0, c.width, c.height)\n    return {\n      width: c.width,\n      height: c.height,\n      data: imgData.data.buffer\n    }\n  }).then(res => {\n    URL.revokeObjectURL(blobURL)\n    return res\n  }, err => {\n    URL.revokeObjectURL(blobURL)\n    throw err\n  })\n}\n\n\n/**\n * It takes an AVIF array, converts it to an OBU array, decodes the OBU array to a BMP array, and\n * returns the BMP array\n * @param client - the client object that was passed to the worker.\n * @param id - The id of the task.\n * @param avifArr - The AVIF data as a Uint8Array.\n */\nexport function polyfillDecodeAvif (client, id, avifArr) {\n  const obuArr = avif2obu(avifArr).data\n  resolveTask(id, toBlob => {\n    if (toBlob) {\n      // console.time(\"dav1d \"+id);\n      const bmpArr = decoderContext.unsafeDecodeFrameAsBMP(obuArr)\n      // console.timeEnd(\"dav1d \"+id);\n      const blob = arr2blob(bmpArr)\n      decoderContext.unsafeCleanup()\n      return blob\n    } else {\n      // Will be transfered so ok to copy.\n      return decoderContext.decodeFrameAsBMP(obuArr)\n    }\n  })\n}\n\n/**\n * It creates a new decoder context, and then sets the client ready flag\n * @param opts - {\n * @returns A promise that resolves to the decoderContext.\n */\nexport function polyfillAvif (opts) {\n  return create({ wasmURL: opts.wasmURL })\n    .then((decoder) => {\n      decoderContext = decoder\n    })\n}\n\n/**\n * If the browser supports the AVIF decoder, use it, otherwise use the polyfill\n * @param client - The client object that was passed to the worker.\n * @param id - The id of the image to decode.\n * @param avifArr - The Uint8Array of the AVIF file.\n * @returns A promise that resolves to an image object.\n */\nexport function decodeAvif (client, id, avifArr) {\n  console.log(waitForClient[client.id])\n  return waitForClient[client.id].ready.then(() => {\n    decoderContext\n      ? polyfillDecodeAvif(client, id, avifArr)\n      : nativeDecodeAvif(client, id, avifArr)\n  })\n}\n\n/**\n * If the user's browser doesn't support AV1, we'll use the polyfill. Otherwise, we'll use the native\n * decoder\n * @param  - `forcePolyfill` - if true, the polyfill will be used even if the browser supports AV1.\n */\nexport function getServiceWorkerOpts ({ forcePolyfill, wasmURL }: { wasmURL: string, forcePolyfill: boolean }) {\n  const usePolyfill = forcePolyfill || !hasAv1Support()\n  return { usePolyfill, wasmURL }\n}\n\n/**\n * It takes a string, splits it on the forward slash character, and returns the last item in the\n * resulting array\n * @param uri - The URI of the file to be downloaded.\n * @returns The last item in the array.\n */\nexport function getFilename (uri) {\n  return uri.split('/').pop()\n}\n\n/**\n * It takes a Blob and returns a new Blob with the same image data but a different file format\n * @param imageBlob - The Blob object you want to convert\n * @param mime - The MIME type of the new Blob.\n * @returns A new Blob object\n */\nfunction blobToBlob (imageBlob, mime): Blob {\n  const canvas = self.createElement('canvas')\n  const context = canvas.getContext('2d')\n\n  let newBlob\n\n  // Create a new Image object and set its source to the Blob URL\n  const img = new Image()\n  img.src = URL.createObjectURL(imageBlob)\n\n  // When the image has loaded, draw it onto the canvas with the desired file format\n  img.onload = function () {\n    canvas.width = img.width\n    canvas.height = img.height\n    context.drawImage(img, 0, 0)\n\n    // Convert the canvas to a new Blob with the desired file format\n    canvas.toBlob(function (nb) {\n      newBlob = nb\n    }, mime)\n  }\n\n  return newBlob\n}\n","import { decodeMov, getFilename, getServiceWorkerOpts } from './decode'\nimport { detectAvifSupport } from './supportDetection'\nimport { inspect } from 'util'\nimport defaultOptions = module\nimport { AVIF_SERVICE_WORKER_FILE } from './constants'\n\n/**\n * It receives a message from the service worker, decodes the message, and sends the decoded message\n * back to the service worker\n * @param event - The event object that was passed to the event handler.\n */\nfunction handleMessage (event) {\n  // Respond to job requests from worker.\n  const msg = event.data\n  if (msg && msg.type === 'avif-mov') {\n    decodeMov(msg.data).then(decoded => {\n      navigator.serviceWorker.controller.postMessage({\n        id: msg.id,\n        type: 'avif-rgba',\n        ...decoded\n      }, [decoded.data])\n    }, err => {\n      navigator.serviceWorker.controller.postMessage({\n        id: msg.id,\n        type: 'avif-error',\n        data: err.message\n      })\n    })\n  }\n}\n\n// See https://redfin.engineering/how-to-fix-the-refresh-button-when-using-service-workers-a8e27af6df68\n// for the Service Worker update best practices.\nasync function register (\n  regPromise: string,\n  opts: AvifPolyfillOptions\n) {\n  opts = { ...defaultOptions, ...opts }\n\n  console.log('initialized with options', opts)\n\n  if (!('serviceWorker' in navigator)) {\n    return await Promise.reject('SERVICE_WORKER_NOT_SUPPORTED')\n  } else if (opts.avifSupport) {\n    return await Promise.reject('AVIF_SUPPORTED')\n  } else if (typeof opts.swURL === 'string') {\n    /**\n     * Service Worker registration\n     */\n    navigator.serviceWorker\n      .register(opts.swURL, { scope: opts.scope })\n      .then((reg: ServiceWorkerRegistration) => {\n        /**\n         * It calls the `onUpdate` function that was passed in as an option, and then it returns the\n         * `forceReload` function\n         *\n         * @param event - The event object\n         */\n        const refresh = (event) => {\n          console.log('update ⚡', event)\n          opts.onUpdate(() => forceReload)\n        }\n\n        /**\n         * It sends a message to the service worker to update the image sources\n         */\n        const forceReload: (reg, options) => void = () => {\n          console.log('🔁 starting Image sources replace')\n          reg.waiting.postMessage({\n            type: 'avif-update',\n            data: getServiceWorkerOpts(opts)\n          })\n        }\n\n        /**\n         * If the service worker is already installed, force a reload. If it's not installed, wait for it to\n         * install and then force a reload\n         */\n        const awaitStateChange: () => void = () => {\n          const waitFor = (navigator.serviceWorker.controller != null) ? 'installed' : 'activated'\n          reg.installing.addEventListener('statechange', function () {\n            if (this.state === waitFor) forceReload(reg)\n          })\n        }\n\n        /**\n         * Events\n         *\n         * Fire avif replace on init\n         */\n        if (reg.active != null) {\n          console.log('🙌 Ready for replace!')\n          const swOpts = getServiceWorkerOpts(opts)\n          reg.active.postMessage({ type: 'avif-replace', data: swOpts })\n        }\n\n        /**\n         *  Reload images src\n         */\n        if (reg.waiting != null) {\n          // TODO: IF IT NEEDS TO BE RELOADED... force reload\n          console.log('⚒️ Force Reload')\n          forceReload(reg, opts)\n        }\n\n        /**\n         * The controllerchange event of the ServiceWorkerContainer interface fires\n         * when the document's associated ServiceWorkerRegistration acquires a new active worker.\n         */\n        navigator.serviceWorker.addEventListener('controllerchange', refresh)\n\n        /* Receive an input from Service Worker */\n        navigator.serviceWorker.addEventListener('message', handleMessage)\n\n        /* A new service worker has been installed */\n        navigator.serviceWorker.addEventListener('updatefound', awaitStateChange)\n\n        return reg\n      })\n  }\n}\n\n/**\n * If the browser doesn't support AVIF, register the service worker. If the browser does support AVIF,\n * unregister the service worker\n * @param options - {\n */\nasync function swInit (options): void {\n  const needsPolyfill = await detectAvifSupport()\n  if (!needsPolyfill) {\n    register(options.swURL, options)\n      .then(() => {\n        console.log('Success! Service Worker installed ✌️')\n      })\n      .catch((err) => {\n        if (err === 'AVIF_SUPPORTED') {\n          console.log('Avif Image format supported by browser 🎉 - polyfill disabled')\n          return\n        }\n        console.log('Error ', err)\n      })\n  } else {\n    const currentSw = navigator.serviceWorker?.controller?.scriptURL\n    if (currentSw && getFilename(currentSw) === AVIF_SERVICE_WORKER_FILE) {\n      console.log('Cleanup 🧽')\n      navigator.serviceWorker.getRegistrations()\n        .then(registrations => {\n          for (const registration of registrations) {\n            if (getFilename(registration?.active?.scriptURL) === AVIF_SERVICE_WORKER_FILE) {\n              registration.unregister().then(() => {\n                console.log('avif service worker uninstalled')\n              })\n            }\n          }\n        })\n    }\n  }\n}\n\nexport {\n  swInit,\n  handleMessage\n}\n","// ISOBMFF constants.\nconst BOX_HEADER_SIZE = 8\nconst BOX_FTYP = 0x66747970\nconst BOX_META = 0x6d657461\nconst BOX_ILOC = 0x696c6f63\nconst BOX_IPRP = 0x69707270\nconst BOX_IPCO = 0x6970636f\nconst BOX_ISPE = 0x69737065\n\n// MOV container stub with single video track.\nconst MOV_HEADER = (function () {\n  const u32 = new Uint32Array([469762048, 1887007846, 1836020585, 131072, 1836020585, 846164841, 825520237, 1140981760, 1987014509, 1811939328, 1684567661, 0, 0, 0, 3892510720, 704643072, 256, 1, 0, 0, 256, 0, 0, 0, 256, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 33554432, 3489726464, 1801548404, 1543503872, 1684564852, 50331648, 0, 0, 16777216, 0, 704643072, 0, 0, 0, 0, 256, 0, 0, 0, 256, 0, 0, 0, 64, 32775, 14340, 1812004864, 1634296941, 536870912, 1684563053, 0, 0, 0, 3227320320, 3909287936, 50261, 553648128, 1919706216, 0, 0, 1701079414, 0, 0, 0, 16777216, 1852402979, 102, 1752004116, 100, 1, 0, 0, 1852400676, 102, 1701995548, 102, 0, 1, 1819440396, 32, 1, 1651799011, 108, 1937011583, 100, 0, 1, 813064559, 49, 0, 1, 0, 0, 0, 75499264, 4718648, 4718592, 0, 65536, 0, 0, 0, 0, 0, 0, 0, 0, 16776984, 1629028352, 2168664438, 167775240, 11, 3284118338, 31915895, 402653184, 1937011827, 0, 16777216, 16777216, 3909287936, 469762048, 1668510835, 0, 16777216, 16777216, 16777216, 16777216, 335544320, 2054386803, 0, 0, 16777216, 335544320, 1868788851, 0, 16777216, 1744961536, 0, 1952539757])\n  return new Uint8Array(u32.buffer)\n})()\nconst MOV_HEADER_SIZE = MOV_HEADER.byteLength\nconst MOV_STSZ_OFFSET = 568\nconst MOV_MDAT_OFFSET = 608\nconst MOV_TKHD_WIDTH_OFFSET = 234\nconst MOV_AV01_WIDTH_OFFSET = 437\n\n/**\n * It throws an error if the first argument is false\n * @param cond - The condition to check.\n * @param str - The string to be parsed.\n */\nfunction assert (cond, str) {\n  if (!cond) throw new Error(str)\n}\n\nfunction findMoovOffset (dataView) {\n  const length = dataView.byteLength\n\n  let offset = 0\n\n  while (offset < length) {\n    const size = dataView.getUint32(offset, false)\n    const type = dataView.getInt32(offset + 4, false)\n\n    if (type === 0x6D6F6F76) {\n      // found the moov atom\n      return offset\n    }\n\n    // move to the next atom\n    offset += size\n  }\n\n  // moov atom not found\n  return null\n}\n\nfunction findAtomOffset (dataView, parentOffset, atomType) {\n  const parentSize = dataView.getUint32(parentOffset, false)\n\n  let offset = parentOffset + 8\n\n  while (offset < parentOffset + parentSize) {\n    const size = dataView.getUint32(offset, false)\n    const type = dataView.getInt32(offset + 4, false)\n\n    if (type === atomType) {\n      // found the atom\n      return offset\n    }\n    offset += size\n  }\n}\n\nfunction getMovHeaderData (source) {\n  // Create a new DataView object from your source data\n  const dataView = new DataView(source);\n\n  // Find the offset of the moov atom\n  const moovOffset = findMoovOffset(dataView);\n\n  // Find the offset of the mvhd atom\n  const mvhdOffset = findAtomOffset(dataView, moovOffset, 'mvhd');\n\n  // Find the offset of the trak atom\n  const trakOffset = findAtomOffset(dataView, moovOffset, 'trak');\n\n  // Find the offset of the tkhd atom\n  const tkhdOffset = findAtomOffset(dataView, trakOffset, 'tkhd');\n\n  // Find the offset of the mdia atom\n  const mdiaOffset = findAtomOffset(dataView, trakOffset, 'mdia');\n\n  // Find the offset of the mdhd atom\n  const mdhdOffset = findAtomOffset(dataView, mdiaOffset, 'mdhd');\n\n  // Find the offset of the stbl atom\n  const stblOffset = findAtomOffset(dataView, mdiaOffset, 'stbl');\n\n  // Find the offset of the stsz atom\n  const stszOffset = findAtomOffset(dataView, stblOffset, 'stsz');\n\n  // Get the timescale and duration from the mvhd atom\n  const timescale = dataView.getUint32(mvhdOffset + 12, false);\n  const duration = dataView.getUint32(mvhdOffset + 16, false);\n\n  // Get the width and height from the tkhd atom\n  const width = dataView.getUint16(tkhdOffset + 76, false);\n  const height = dataView.getUint16(tkhdOffset + 78, false);\n\n  // Get the number of frames from the mdhd atom\n  const frameCount = dataView.getUint32(mdhdOffset + 16, false) / timescale;\n\n  // Get the bit depth from the stsz atom\n  const bitDepth = dataView.getUint16(stszOffset + 24, false);\n}\n\n/**\n * It parses the AVIF file\n * header, extracts the image dimensions and the actual image data, and returns\n * them as an object\n * @param ab - The ArrayBuffer of the AVIF file.\n * @returns An object with the width, height, and data of the image.\n */\nexport function avif2obu (ab) {\n  function getU8 () { const v = view.getUint8(pos); pos += 1; return v }\n  function getU16 () { const v = view.getUint16(pos); pos += 2; return v }\n  function getU32 () { const v = view.getUint32(pos); pos += 4; return v }\n\n  const view = new DataView(ab)\n  const len = ab.byteLength\n  let pos = 0\n\n  let brandsCheck = false\n  let width = 0\n  let height = 0\n  let data = null\n\n  while (pos < len) {\n    const size = getU32()\n    const type = getU32()\n    const end = pos + size - BOX_HEADER_SIZE\n    assert(size >= BOX_HEADER_SIZE, 'corrupted file')\n\n    // TODO(Kagami): Add box version checks!\n    switch (type) {\n      case BOX_FTYP:\n      // FIXME(Kagami): Check brands.\n      // TODO(Kagami): Also check that meta/hdlr.handler = \"pict\".\n        brandsCheck = true\n        break\n      case BOX_META:\n        pos += 1 // version\n        pos += 3 // flags\n        continue\n      case BOX_IPRP:\n        continue\n      case BOX_IPCO:\n        continue\n      case BOX_ISPE:\n        pos += 1 // version\n        pos += 3 // flags\n        width = getU32()\n        height = getU32()\n        break\n      case BOX_ILOC:\n        pos += 1 // version\n        pos += 3 // flags\n        const offsetSizeAndLengthSize = getU8()\n        const offsetSize = offsetSizeAndLengthSize >>> 4\n        assert(offsetSize < 8, 'unsupported offset size')\n        const lengthSize = offsetSizeAndLengthSize & 0xf\n        assert(lengthSize < 8, 'unsupported length size')\n        const baseOffsetSize = getU8() >>> 4\n        assert(baseOffsetSize < 8, 'unsupported base offset size')\n        const itemCount = getU16()\n        assert(itemCount >= 1, 'bad iloc items number')\n        // XXX(Kagami): Choosing first item for simplicity.\n        // TODO(Kagami): Use primary item (meta/pitm/item_ID).\n        // TODO(Kagami): Also check that meta/iinf/infe[i].item_type = \"av01\".\n        pos += 2 // item_ID\n        pos += 2 // data_reference_index\n        const baseOffset = baseOffsetSize === 4 ? getU32() : 0\n        pos += 2 // extent_count (>= 1)\n        // XXX(Kagami): What should we do if extent_count > 1?\n        const extentOffset = offsetSize === 4 ? getU32() : 0\n        const extentLength = lengthSize === 4 ? getU32() : 0\n        const u8 = new Uint8Array(ab)\n        const offset = baseOffset + extentOffset\n        data = u8.subarray(offset, offset + extentLength)\n        break\n    }\n\n    pos = end\n  }\n\n  assert(brandsCheck, 'bad brands')\n  assert(width && height, 'bad image width or height')\n  assert(data, 'picture data not found')\n  return { width, height, data }\n}\n\n/**\n * It takes a WebM file and converts it to a MOV file\n * Embed OBU into MOV container stub as video frame.\n * TODO(Kagami): Fix matrix, bitdepth, av1C metadata.\n * @param  - `width` - the width of the video\n * @returns An ArrayBuffer\n */\nexport function obu2mov ({ width, height, data }) {\n  const fileSize = MOV_HEADER_SIZE + data.byteLength\n  const ab = new ArrayBuffer(fileSize)\n  const view = new DataView(ab)\n  const u8 = new Uint8Array(ab)\n  u8.set(MOV_HEADER)\n  u8.set(data, MOV_HEADER_SIZE)\n  // |....|stsz|.|...|xxxx|\n  view.setUint32(MOV_STSZ_OFFSET + BOX_HEADER_SIZE + 4, data.byteLength)\n  // |xxxx|mdat|\n  view.setUint32(MOV_MDAT_OFFSET, data.byteLength + BOX_HEADER_SIZE)\n  // |xxxx|xxxx|\n  view.setUint32(MOV_TKHD_WIDTH_OFFSET, width)\n  view.setUint32(MOV_TKHD_WIDTH_OFFSET + 4, height)\n  // |xx|xx|\n  view.setUint16(MOV_AV01_WIDTH_OFFSET, width)\n  view.setUint16(MOV_AV01_WIDTH_OFFSET + 2, height)\n  return ab\n}\n\n/**\n * Remux AVIF picture as MOV video with single frame.\n * @param ab - ArrayBuffer of the AVIF file\n * @returns A function that takes an array buffer\n */\nexport function avif2mov (ab) {\n  return obu2mov(avif2obu(ab))\n}\n","export const isEdge = navigator.userAgent.includes('Edge')\n\n/**\n * Registers the service worker.\n *\n * @param url\n * @return ServiceWorkerRegistration\n */\nexport async function registerSW (url: string) {\n  if ('serviceWorker' in navigator) {\n    // Register a service worker hosted at the root of the\n    // site using the default scope.\n    navigator.serviceWorker\n      .register(url)\n      .then((registration) => {\n        console.log('Service worker registration succeeded:', registration)\n        return registration\n      })\n      .catch((error) => {\n        console.error(`Service worker registration failed: ${error}`)\n      })\n  } else {\n    console.log('Service workers are not supported.')\n  }\n}\n","\n/**\n * It creates an image element, sets its source to a base64 encoded AVIF image, and then returns true\n * if the image loads successfully\n * https://stackoverflow.com/questions/5573096/detecting-webp-support\n *\n * @returns A boolean value.\n */\nexport async function detectAvifSupport (): Promise<boolean> {\n  const testImageSources = [\n    'data:image/avif;base64,AAAAHGZ0eXBtaWYxAAAAAG1pZjFhdmlmbWlhZgAAAPFtZXRhAAAAAAAAACFoZGxyAAAAAAAAAABwaWN0AAAAAAAAAAAAAAAAAAAAAA5waXRtAAAAAAABAAAAHmlsb2MAAAAABEAAAQABAAAAAAEVAAEAAAAfAAAAKGlpbmYAAAAAAAEAAAAaaW5mZQIAAAAAAQAAYXYwMUltYWdlAAAAAHBpcHJwAAAAUWlwY28AAAAUaXNwZQAAAAAAAAABAAAAAQAAABBwYXNwAAAAAQAAAAEAAAAVYXYxQ4EgAAAKBzgABpAQ0AIAAAAQcGl4aQAAAAADCAgIAAAAF2lwbWEAAAAAAAAAAQABBAECg4QAAAAnbWRhdAoHOAAGkBDQAjIUFkAAAEgAAAwGbmVx8APS84zVsoA='\n  ]\n\n  const testImage = async (src: string): Promise<boolean> => {\n    return await new Promise(resolve => {\n      const img = document.createElement('img')\n      img.onerror = () => { resolve(false) }\n      img.onload = () => { resolve(true) }\n      img.src = src\n    })\n  }\n\n  const results = await Promise.all(testImageSources.map(testImage))\n\n  return results.every(result => !!result)\n}\n\n/**\n * \"If the browser can play a video with the codec av01.0.05M.08, then it supports AV1.\"\n *\n * The function is pretty simple. It creates a video element, and then checks if the browser can play a\n * video with the codec av01.0.05M.08. If it can, then it returns \"probably\". If it can't, then it\n * returns \"\"\n *\n * @returns A boolean value.\n */\nexport function hasAv1Support (): boolean {\n  const vid = document.createElement('video')\n  return vid.canPlayType('video/mp4; codecs=\"av01.0.05M.08\"') === 'probably'\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.hmd = (module) => {\n\tmodule = Object.create(module);\n\tif (!module.children) module.children = [];\n\tObject.defineProperty(module, 'exports', {\n\t\tenumerable: true,\n\t\tset: () => {\n\t\t\tthrow new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);\n\t\t}\n\t});\n\treturn module;\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n",""],"names":["TOTAL_MEMORY","TOTAL_STACK","PAGE_SIZE","TABLE_SIZE","getRuntime","dynamicTop","table","WebAssembly","Table","initial","maximum","element","memory","Memory","HEAPU8","Uint8Array","buffer","sbrk","increment","oldDynamicTop","emscripten_memcpy_big","dest","src","num","set","subarray","pthread_cond_wait","cond","mutex","pthread_cond_signal","pthread_cond_destroy","pthread_cond_init","attr","pthread_cond_broadcast","pthread_join","thread","res","pthread_create","func","arg","fetchAndInstantiate","data","url","imports","instantiate","req","fetch","credentials","instantiateStreaming","then","arrayBuffer","create","opts","wasmURL","wasmData","Promise","reject","Error","runtime","env","wasm","d","Dav1d","_init","DJS_FORMAT_YUV","DJS_FORMAT_BMP","FFI","instance","exports","ref","lastFrameRef","djs_init","obu","format","unsafe","ArrayBuffer","isView","obuRef","djs_alloc_obu","byteLength","frameRef","djs_decode_obu","frameInfo","Uint32Array","width","height","size","dataRef","srcData","djs_free_frame","_decodeFrame","avif2mov","rasterFormat","waitForClient","arr2blob","bmpArr","Blob","type","setClientReady","cid","resolve","ready","setClientWaiting","nativeDecodeAvif","client","id","avifArr","movArr","postMessage","rgba2bmp","decodeAvif","polyfillAvif","CACHE_NAME","CACHE_VERSION","CURRENT_CACHES","AvifCache","taskById","taskCounter","resolveTask","taskId","cb","task","toBlob","rejectTask","err","self","addEventListener","event","skipWaiting","currentCaches","waitUntil","caches","keys","cacheNames","filter","cacheName","includes","cachesToDelete","all","map","cacheToDelete","clients","claim","undefined","msg","console","log","source","sessionStorage","clear","message","request","match","clientId","respondWith","open","cache","cachedResponse","get","clone","blob","put","Response","error","ab","w","h","setU16","v","view","setUint16","pos","setU32","setUint32","headerSize","stride","Math","floor","pixelArraySize","fileLength","file","DataView","data32","w3","pos32","y","shift","x","abgr","bg","r","setUint8","AVIF_SERVICE_WORKER_FILE","avifPolyfillOptions","onUpdate","swURL","forcePolyfill","scope","isEdge","hasAv1Support","avif2obu","decoderContext","decodeMov","arr","blobURL","URL","createObjectURL","vid","document","createElement","mozDecodedFrames","webkitDecodedFrameCount","muted","play","c","ctx","getContext","videoWidth","videoHeight","drawImage","imgData","getImageData","revokeObjectURL","polyfillDecodeAvif","obuArr","unsafeDecodeFrameAsBMP","unsafeCleanup","decodeFrameAsBMP","decoder","getServiceWorkerOpts","usePolyfill","getFilename","uri","split","pop","blobToBlob","imageBlob","mime","canvas","context","newBlob","img","Image","onload","nb","detectAvifSupport","defaultOptions","module","handleMessage","decoded","navigator","serviceWorker","controller","register","regPromise","avifSupport","reg","refresh","forceReload","waiting","awaitStateChange","waitFor","installing","state","active","swOpts","swInit","options","needsPolyfill","currentSw","scriptURL","getRegistrations","registrations","registration","unregister","BOX_HEADER_SIZE","BOX_FTYP","BOX_META","BOX_ILOC","BOX_IPRP","BOX_IPCO","BOX_ISPE","MOV_HEADER","u32","MOV_HEADER_SIZE","MOV_STSZ_OFFSET","MOV_MDAT_OFFSET","MOV_TKHD_WIDTH_OFFSET","MOV_AV01_WIDTH_OFFSET","assert","str","findMoovOffset","dataView","length","offset","getUint32","getInt32","findAtomOffset","parentOffset","atomType","parentSize","getMovHeaderData","moovOffset","mvhdOffset","trakOffset","tkhdOffset","mdiaOffset","mdhdOffset","stblOffset","stszOffset","timescale","duration","getUint16","frameCount","bitDepth","getU8","getUint8","getU16","getU32","len","brandsCheck","end","offsetSizeAndLengthSize","offsetSize","lengthSize","baseOffsetSize","itemCount","baseOffset","extentOffset","extentLength","u8","obu2mov","fileSize","userAgent","registerSW","testImageSources","testImage","onerror","results","every","result","canPlayType"],"sourceRoot":""}