{"version":3,"file":"dist/avif-polyfill.js","mappings":"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","sources":["webpack://avif.js/webpack/universalModuleDefinition","webpack://avif.js/webpack/bootstrap","webpack://avif.js/webpack/runtime/define property getters","webpack://avif.js/webpack/runtime/hasOwnProperty shorthand","webpack://avif.js/webpack/runtime/make namespace object","webpack://avif.js/./src/registration.ts","webpack://avif.js/./src/decode.ts","webpack://avif.js/./src/supportDetection.ts","webpack://avif.js/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"avifPolyfill\"] = factory();\n\telse\n\t\troot[\"avifPolyfill\"] = factory();\n})(this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const isEdge = navigator.userAgent.includes('Edge')\n\n/**\n * Registers the service worker.\n *\n * @param url\n * @return ServiceWorkerRegistration\n */\nexport async function registerSW (url: string) {\n  if ('serviceWorker' in navigator) {\n    // Register a service worker hosted at the root of the\n    // site using the default scope.\n    navigator.serviceWorker\n      .register(url)\n      .then((registration) => {\n        console.log('Service worker registration succeeded:', registration)\n        return registration\n      })\n      .catch((error) => {\n        console.error(`Service worker registration failed: ${error}`)\n      })\n  } else {\n    console.log('Service workers are not supported.')\n  }\n}\n","import { isEdge } from './registration'\nimport { hasAv1Support } from './supportDetection'\n\n/**\n * Decode AVIF data using native browser's AV1 decoder.\n * It creates a video element, sets its src to the input, waits for the video to load, then draws the\n * video to a canvas and returns the canvas's image data\n * @param {ArrayBufferView | ArrayBuffer | Blob | string} arr - ArrayBufferView | ArrayBuffer | Blob |\n * string\n * @returns A promise that resolves to an object with a width, height, and data property.\n */\nexport async function decodeMov (arr: ArrayBufferView | ArrayBuffer | Blob | string) {\n  const blob = new Blob([arr], { type: 'video/mp4' })\n  const blobURL = URL.createObjectURL(blob)\n  return await new Promise((resolve, reject) => {\n    const vid: HTMLVideoElement = document.createElement('video')\n    vid.addEventListener(isEdge ? 'ended' : 'loadeddata', () => {\n      if ((vid.mozDecodedFrames == null ||\n          vid.mozDecodedFrames > 0) &&\n        (vid.webkitDecodedFrameCount == null ||\n          vid.webkitDecodedFrameCount > 0)) {\n        resolve(vid)\n      } else {\n        reject(new Error('partial AV1 frame'))\n      }\n    })\n    vid.addEventListener('error', () => {\n      reject(new Error('cannot decode AV1 frame'))\n    })\n    vid.muted = true\n    vid.src = blobURL\n    vid.play()\n  }).then(vid => {\n    const c = document.createElement('canvas')\n    const ctx = c.getContext('2d')\n    c.width = vid.videoWidth\n    c.height = vid.videoHeight\n    ctx.drawImage(vid, 0, 0, c.width, c.height)\n    const imgData = ctx.getImageData(0, 0, c.width, c.height)\n    return {\n      width: c.width,\n      height: c.height,\n      data: imgData.data.buffer\n    }\n  }).then(res => {\n    URL.revokeObjectURL(blobURL)\n    return res\n  }, err => {\n    URL.revokeObjectURL(blobURL)\n    throw err\n  })\n}\n\nexport function getServiceWorkerOpts ({ forcePolyfill, wasmURL }): { wasmURL: string, usePolyfill: boolean } {\n  const usePolyfill = forcePolyfill || !hasAv1Support()\n  return { usePolyfill, wasmURL }\n}\n","// https://stackoverflow.com/questions/5573096/detecting-webp-support\nexport async function detectAvifSupport(): Promise<boolean> {\n\n  const testImageSources = [\n    \"data:image/avif;base64,AAAAHGZ0eXBtaWYxAAAAAG1pZjFhdmlmbWlhZgAAAPFtZXRhAAAAAAAAACFoZGxyAAAAAAAAAABwaWN0AAAAAAAAAAAAAAAAAAAAAA5waXRtAAAAAAABAAAAHmlsb2MAAAAABEAAAQABAAAAAAEVAAEAAAAfAAAAKGlpbmYAAAAAAAEAAAAaaW5mZQIAAAAAAQAAYXYwMUltYWdlAAAAAHBpcHJwAAAAUWlwY28AAAAUaXNwZQAAAAAAAAABAAAAAQAAABBwYXNwAAAAAQAAAAEAAAAVYXYxQ4EgAAAKBzgABpAQ0AIAAAAQcGl4aQAAAAADCAgIAAAAF2lwbWEAAAAAAAAAAQABBAECg4QAAAAnbWRhdAoHOAAGkBDQAjIUFkAAAEgAAAwGbmVx8APS84zVsoA=\"\n  ]\n\n  const testImage = (src: string): Promise<boolean> => {\n    return new Promise(resolve => {\n      var img = document.createElement(\"img\")\n      img.onerror = () => resolve(false)\n      img.onload = () => resolve(true)\n      img.src = src\n    })\n  }\n\n  const results = await Promise.all(testImageSources.map(testImage))\n\n  return results.every(result => !!result)\n}\n\n\n\n/**\n * \"If the browser can play a video with the codec av01.0.05M.08, then it supports AV1.\"\n *\n * The function is pretty simple. It creates a video element, and then checks if the browser can play a\n * video with the codec av01.0.05M.08. If it can, then it returns \"probably\". If it can't, then it\n * returns \"\"\n *\n * @returns A boolean value.\n */\nexport function hasAv1Support(): boolean {\n  const vid = document.createElement(\"video\");\n  return vid.canPlayType('video/mp4; codecs=\"av01.0.05M.08\"') === \"probably\";\n}\n","import { decodeMov, getServiceWorkerOpts } from './decode'\n\n// Respond to job requests from worker.\nfunction handleMessage (event) {\n  const msg = event.data\n  if (msg && msg.type === 'avif-mov') {\n    decodeMov(msg.data).then(decoded => {\n      navigator.serviceWorker.controller.postMessage({\n        id: msg.id,\n        type: 'avif-rgba',\n        ...decoded\n      }, [decoded.data])\n    }, err => {\n      navigator.serviceWorker.controller.postMessage({\n        id: msg.id,\n        type: 'avif-error',\n        data: err.message\n      })\n    })\n  }\n}\n\n// See https://redfin.engineering/how-to-fix-the-refresh-button-when-using-service-workers-a8e27af6df68\n// for the Service Worker update best practices.\nasync function register (regPromise: Promise<ServiceWorkerRegistration> | string, opts: { wasmURL?: string, scope?: string, onUpdate?: any, confirmUpdate?: any, forcePolyfill?: boolean }) {\n  if (!('serviceWorker' in navigator)) {\n    return await Promise.reject(new Error('Service Worker API is not supported'))\n  }\n\n  if (typeof opts === 'function') {\n    opts = { confirmUpdate: opts }\n  }\n  opts = Object.assign({\n    confirmUpdate: () => true,\n    onUpdate: () => null,\n    wasmURL: '/dist/dav1d.wasm',\n    forcePolyfill: false,\n    scope: './'\n  }, opts)\n\n  if (typeof regPromise === 'string') {\n    const regOpts = opts.scope ? { scope: opts.scope } : undefined\n    regPromise = navigator.serviceWorker.register(regPromise, regOpts)\n  }\n\n  await regPromise.then((reg: ServiceWorkerRegistration) => {\n\n    let refreshing = false\n\n    const refresh = () => {\n      if (refreshing) return\n      refreshing = true\n      console('update ⚡')\n      opts.onUpdate(reg)\n    }\n    const promptUserToRefresh = () => {\n      Promise.resolve(opts.confirmUpdate(reg)).then(shouldUpdate => {\n        if (shouldUpdate) {\n          if (navigator.serviceWorker.controller != null) {\n            navigator.serviceWorker.waiting.postMessage({ type: 'avif-update' })\n          } else {\n            refresh()\n          }\n        }\n      })\n    }\n\n    const awaitStateChange = function () {\n      const waitFor = (navigator.serviceWorker.controller != null) ? 'installed' : 'activated'\n      navigator.serviceWorker.installing.addEventListener('statechange', function () {\n        if (this.state === waitFor) promptUserToRefresh()\n      })\n    }\n\n    navigator.serviceWorker.addEventListener('controllerchange', refresh)\n    navigator.serviceWorker.addEventListener('message', handleMessage)\n    if (navigator.serviceWorker.controller != null) {\n      const swOpts = getServiceWorkerOpts(opts)\n      navigator.serviceWorker.controller.postMessage({ type: 'avif-ready', data: swOpts })\n    }\n\n    if (navigator.serviceWorker.waiting) { promptUserToRefresh(); return }\n    navigator.serviceWorker.addEventListener('updatefound', awaitStateChange)\n  })\n}\n\nfunction swInit (options: { swUrl: string, wasmURL: string }) {\n  register(navigator.serviceWorker.register(options.swUrl), {\n    wasmURL: options.wasmURL\n  })\n}\n\nexport {\n  swInit,\n  handleMessage\n}\n"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","isEdge","navigator","userAgent","includes","i","arr","blob","Blob","type","blobURL","URL","createObjectURL","Promise","resolve","reject","vid","document","createElement","addEventListener","mozDecodedFrames","webkitDecodedFrameCount","Error","muted","src","play","then","c","ctx","getContext","width","videoWidth","height","videoHeight","drawImage","imgData","getImageData","data","buffer","res","revokeObjectURL","err","getServiceWorkerOpts","forcePolyfill","wasmURL","usePolyfill","canPlayType","handleMessage","event","msg","decodeMov","decoded","serviceWorker","controller","postMessage","id","message","regPromise","opts","confirmUpdate","assign","onUpdate","scope","regOpts","undefined","register","reg","refreshing","refresh","console","promptUserToRefresh","shouldUpdate","waiting","swOpts","waitFor","installing","state","swInit","options","swUrl"],"sourceRoot":""}